# Glean
** a fixture generator for Laravel **

This library provides a Laravel Artisan command which generates fixture files from the output of any object method.  It leverages Laravel's Service Container and PHP's Reflection capabilities to instantiate classes and call the desired object methods with the specified arguments. Data may be saved in raw PHP, YAML, JSON, or XML.

## Use Case

While there are quite a few test double libraries designed to ingest fixtures (which reflect model classes) for the purpose of database seeding, in complex applications, it may be desirable to have reusable fixture data from other types of classes (i.e. services).  _Glean_ provides an easy way to capture arbitrary/complex data structures.  The fixture files generated by this tool are intended to be used with unit tests in any case where you might need to reuse expectation data (i.e. stubbing).  

## Usage

1. `composer require shift31/glean`
2. Add `Shift31\Glean\GleanServiceProvider` to the `'providers'` array in your app/config/app.php.

### Help

Run `php artisan help glean` from the root of your Laravel project

### Examples

Imagine a `Acme\Users\UsersService` class with a `getUserRoles($userId)` method that returns an array of roles for a particular user:

`php artisan glean -a user_roles 'Acme\Users\UsersService' getUserRoles 12345`

By default, this will generate a PHP file in app/storage/fixtures called user_roles.php with the data _gleaned_ from `UsersService::getUserRoles`.

#### With interfaces

_Glean_ resolves classes using Laravel's Service Container, so feel free to specify an interface for the `className` argument.


#### In a test

```php
$expectedUserRoles = include(__DIR__ . '/../app/storage/fixtures/user_roles.php');
```

## Limitations

Method arguments can only be PHP scalar values or `null`.  A possible workaround for this is to extend the `GleanCommand` class and create your own custom "gleaner."

## Todo

* Build a fixture loader
* Make it framework-agnostic?
* Make writing custom gleaners easier?
